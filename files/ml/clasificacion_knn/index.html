<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KNN Clasificación 2D — demo interactiva</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1428; --ink:#e7ecf3; --muted:#9aa4b2; --accent:#78a6ff; --border:#1e2646;
      --ok:#21c07a; --warn:#ffb454; --err:#ef476f;
      --c0:#8ec5ff; --c1:#ffd166;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--ink);
      background:radial-gradient(1200px 700px at 20% -10%, #162045 0%, var(--bg) 50%);
      font:15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif;
    }
    .container{max-width:1100px; margin:0 auto; padding:28px 16px 60px;}
    header{display:grid; gap:8px; margin-bottom:18px}
    h1{margin:0; font-size:clamp(22px, 2vw + 16px, 34px)}
    .muted{color:var(--muted)}
    .grid{display:grid; gap:16px; grid-template-columns:repeat(12,1fr)}
    .card{
      grid-column:span 8; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
      border:1px solid var(--border); border-radius:18px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.2)
    }
    .side{grid-column:span 4; display:flex; flex-direction:column; gap:16px}
    @media (max-width: 980px){ .card,.side{grid-column:1 / -1} }
    canvas{width:100%; height:520px; display:block; background:#0c1226; border:1px solid var(--border); border-radius:14px}

    .controls{display:grid; gap:12px}
    .row{display:grid; grid-template-columns: 170px 1fr auto; gap:10px; align-items:center}
    .row input[type="range"]{width:100%}
    .pill{display:inline-block; background:#0e1a3c; border:1px solid var(--border); border-radius:999px; padding:2px 8px; font-size:12px; color:var(--muted)}
    .legend{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .dot{width:10px; height:10px; border-radius:50%}
    .c0{background:var(--c0)} .c1{background:var(--c1)}
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:8px 12px; border-radius:12px; border:1px solid var(--border);
      background:#0f1734; color:var(--ink); cursor:pointer; user-select:none
    }
    .btn:active{transform:translateY(1px)}
    .panel{background:#0f1428; border:1px solid var(--border); border-radius:14px; padding:12px}
    .mono{font:13px/1.6 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    details{border:1px solid var(--border); border-radius:12px; background:#0d1328; padding:10px}
    summary{cursor:pointer}
    table{width:100%; border-collapse:collapse; font-size:13px}
    th,td{padding:6px 8px; border-bottom:1px solid #141a33; text-align:right}
    th:first-child, td:first-child{text-align:left}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    input[type="number"], select{
      background:#0d1631; color:var(--ink); border:1px solid var(--border); border-radius:10px; padding:6px 8px; width:100%;
    }
    .cols{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    @media (max-width:560px){ .row{grid-template-columns: 130px 1fr auto} .cols{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>KNN Clasificación 2D</h1>
      <div class="muted">
        Ajustá <strong>K</strong> y la <strong>distancia</strong> para ver cómo cambia la frontera y las métricas. Fondo = probabilidad estimada (promedio de vecinos).
      </div>
      <div class="legend">
        <span class="pill"><span class="dot c0"></span> clase 0</span>
        <span class="pill"><span class="dot c1"></span> clase 1</span>
        <span class="pill">frontera: <em>p=0.5</em></span>
      </div>
    </header>

    <section class="grid">
      <div class="card">
        <canvas id="plot" width="900" height="520" aria-label="Plano X1–X2 con KNN"></canvas>
      </div>

      <aside class="side">
        <div class="panel controls">
          <div class="row">
            <label for="k">Vecinos (K)</label>
            <input id="k" type="range" min="1" max="50" step="1" value="15" />
            <output id="kVal">15</output>
          </div>

          <div class="row">
            <label for="metric">Distancia</label>
            <select id="metric">
              <option value="l2">Euclídea (L2)</option>
              <option value="l1">Manhattan (L1)</option>
              <option value="linf">Chebyshev (L∞)</option>
              <option value="mink">Minkowski (p)</option>
            </select>
            <span></span>
          </div>

          <div class="row" id="pRow" style="display:none;">
            <label for="p">Orden p (Minkowski)</label>
            <input id="p" type="range" min="0.5" max="5" step="0.1" value="2.0" />
            <output id="pVal">2.0</output>
          </div>

          <div class="cols">
            <div>
              <label class="muted" for="shape">Datos</label>
              <select id="shape">
                <option value="moons">Dos lunas</option>
                <option value="circles">Círculos concéntricos</option>
              </select>
            </div>
            <div>
              <label class="muted" for="sigma">Ruido σ</label>
              <input id="sigma" type="number" step="0.05" value="0.25" />
            </div>
          </div>

          <div class="cols">
            <div>
              <label class="muted" for="n">Muestras N</label>
              <input id="n" type="number" min="60" max="2000" step="20" value="300" />
            </div>
            <div>
              <label class="muted" for="seed">Semilla</label>
              <input id="seed" type="number" step="1" value="1234" />
            </div>
          </div>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:6px;">
            <button id="regen" class="btn" type="button">Regenerar datos</button>
            <label class="muted" style="display:flex; align-items:center; gap:6px;">
              <input id="toggleProb" type="checkbox" checked/> Fondo según probabilidad
            </label>
            <label class="muted" style="display:flex; align-items:center; gap:6px;">
              <input id="toggleErr" type="checkbox" checked/> Resaltar mal clasificados
            </label>
            <button id="resetGood" class="btn" type="button">Reset razonable</button>
          </div>
        </div>

        <div class="panel mono" id="metrics">
          <div><strong>Accuracy:</strong> <span id="acc" class="ok">–</span></div>
          <div><strong>LogLoss:</strong> <span id="ll">–</span></div>
        </div>

        <details>
          <summary class="muted">Matriz de confusión (muestral si N grande)</summary>
          <div style="margin-top:8px;">
            <table id="cm">
              <thead>
                <tr><th></th><th>Pred 0</th><th>Pred 1</th></tr>
              </thead>
              <tbody>
                <tr><td>True 0</td><td id="tn">–</td><td id="fp">–</td></tr>
                <tr><td>True 1</td><td id="fn">–</td><td id="tp">–</td></tr>
              </tbody>
            </table>
          </div>
        </details>
      </aside>
    </section>
  </div>

  <script>
    // ---------- Utils ----------
    function mulberry32(seed){ let t = seed>>>0; return function(){
      t += 0x6D2B79F5; let r = Math.imul(t ^ (t>>>15), 1|t); r ^= r + Math.imul(r ^ (r>>>7), 61|r);
      return ((r ^ (r>>>14))>>>0) / 4294967296;
    }}
    function randn(rng){ let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
    const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
    const lerp  = (a,b,t)=> a + (b-a)*t;

    // ---------- Estado ----------
    const state = {
      data: [], xarr:null, yarr:null, larr:null, // Typed arrays para velocidad
      xlim: [-3,3], ylim: [-3,3],
      k: 15, metric: 'l2', p: 2.0,
      shape: 'moons', sigma: 0.25, n: 300, seed: 1234,
      showProb: true, highlightErrors: true,
      gridCache: null, // {cols,rows,xmin,xmax,ymin,ymax, P: Float32Array((rows+1)*(cols+1))}
    };

    // ---------- DOM ----------
    const $ = (sel)=>document.querySelector(sel);
    const canvas = $('#plot'), ctx = canvas.getContext('2d');

    const kInp=$('#k'), kVal=$('#kVal');
    const metricSel=$('#metric'), pRow=$('#pRow'), pInp=$('#p'), pVal=$('#pVal');
    const shapeSel=$('#shape'), sigmaInp=$('#sigma'), nInp=$('#n'), seedInp=$('#seed');
    const regenBtn=$('#regen'), toggleProb=$('#toggleProb'), toggleErr=$('#toggleErr'), resetGoodBtn=$('#resetGood');

    const accEl=$('#acc'), llEl=$('#ll'), tnEl=$('#tn'), fpEl=$('#fp'), fnEl=$('#fn'), tpEl=$('#tp');

    // ---------- Generación de datos ----------
    function genData(){
      const rng = mulberry32(+state.seed || 0);
      const N   = Math.max(60, +state.n|0);
      const s   = Math.max(0, +state.sigma);
      const arr=[];

      if (state.shape === 'moons'){
        for (let i=0;i<N;i++){
          const y = i%2;
          const angle = Math.PI * (rng()*0.9 + 0.05);
          if (y===0){
            const r=1;
            const x1 =  r*Math.cos(angle) + randn(rng)*s;
            const x2 =  r*Math.sin(angle) + randn(rng)*s;
            arr.push({x1,x2,y});
          } else {
            const r=1;
            const x1 = -r*Math.cos(angle) + 1.0 + randn(rng)*s;
            const x2 = -r*Math.sin(angle) - 0.2 + randn(rng)*s;
            arr.push({x1,x2,y});
          }
        }
      } else {
        for (let i=0;i<N;i++){
          const y = i%2;
          const angle = 2*Math.PI*rng();
          const r = (y===0 ? 0.8 : 1.6) + randn(rng)*s;
          const x1 = r*Math.cos(angle);
          const x2 = r*Math.sin(angle);
          arr.push({x1,x2,y});
        }
      }

      state.data = arr;
      // typed arrays
      state.xarr = new Float32Array(arr.map(d=>d.x1));
      state.yarr = new Float32Array(arr.map(d=>d.x2));
      state.larr = new Uint8Array(arr.map(d=>d.y));

      // bounds automáticos
      const xs=state.xarr, ys=state.yarr;
      let xmin=Math.min(...xs), xmax=Math.max(...xs);
      let ymin=Math.min(...ys), ymax=Math.max(...ys);
      const padX = 0.15*(xmax-xmin||1), padY = 0.15*(ymax-ymin||1);
      state.xlim=[xmin-padX,xmax+padX]; state.ylim=[ymin-padY,ymax+padY];

      // invalidar cache de grilla
      state.gridCache = null;
    }

    // ---------- Distancias ----------
    function dist(dx,dy){
      const ax = Math.abs(dx), ay = Math.abs(dy);
      switch(state.metric){
        case 'l2':   return dx*dx + dy*dy;          // L2^2 (evitamos sqrt)
        case 'l1':   return ax + ay;                // L1
        case 'linf': return Math.max(ax, ay);       // L∞
        case 'mink': {
          const p = Math.max(0.5, +state.p || 2);
          // No hacemos raíz: (|dx|^p + |dy|^p) basta para ordenar
          return Math.pow(ax, p) + Math.pow(ay, p);
        }
      }
    }

    // ---------- KNN en un punto (probabilidad clase 1) ----------
    function knnProbAt(x, y){
      const X=state.xarr, Y=state.yarr, L=state.larr;
      const n = X.length, K = Math.min(state.k, n);
      // top-K simple: mantenemos K distancias máximas
      const dists = new Float64Array(K).fill(Infinity);
      const labs  = new Uint8Array(K);
      let maxIdx = 0; // índice del mayor en 'dists'
      let maxVal = Infinity;

      for (let i=0;i<n;i++){
        const d = dist(x - X[i], y - Y[i]);
        if (d < dists[maxIdx]){
          dists[maxIdx] = d;
          labs[maxIdx]  = L[i];
          // recomputar máximo actual
          maxIdx = 0; maxVal = dists[0];
          for (let j=1;j<K;j++){ if (dists[j] > maxVal){ maxVal=dists[j]; maxIdx=j; } }
        }
      }
      let sum=0; for (let j=0;j<K;j++) sum += labs[j];
      return sum / K;
    }

    // ---------- Métricas (muestral si es grande) ----------
    function evaluate(){
      const n = state.data.length;
      const sampleCap = (n>400 || state.k>30) ? 400 : n; // muestra para rapidez
      const step = Math.max(1, Math.floor(n / sampleCap));
      const eps = 1e-9;
      let correct=0, ll=0, tn=0, tp=0, fn=0, fp=0, m=0;

      for (let i=0;i<n;i+=step){
        const x=state.xarr[i], y=state.yarr[i], ytrue=state.larr[i];
        const p = knnProbAt(x,y);
        const yhat = (p>=0.5)?1:0;
        if (yhat===ytrue) correct++;
        ll += -(ytrue*Math.log(clamp(p,eps,1-eps)) + (1-ytrue)*Math.log(clamp(1-p,eps,1-eps)));
        if (ytrue===1 && yhat===1) tp++;
        else if (ytrue===1 && yhat===0) fn++;
        else if (ytrue===0 && yhat===1) fp++;
        else tn++;
        m++;
      }
      return { acc: correct/m, ll: ll/m, tn, fp, fn, tp };
    }

    // ---------- Grilla (probabilidad + contorno p=0.5) ----------
    function getGrid(colsWanted){
      const [xmin,xmax]=state.xlim,[ymin,ymax]=state.ylim;
      const rect = canvas.getBoundingClientRect();
      const plotW = Math.max(1, rect.width - 64); // aprox para proporción
      const plotH = Math.max(1, rect.height - 62);
      let cols = colsWanted;
      let rows = Math.max(1, Math.round(cols * plotH/plotW));
      // cache hit?
      const gc = state.gridCache;
      if (gc && gc.cols===cols && gc.rows===rows && gc.xmin===xmin && gc.xmax===xmax && gc.ymin===ymin && gc.ymax===ymax){
        return gc;
      }
      const P = new Float32Array((rows+1)*(cols+1));
      for (let j=0;j<=rows;j++){
        const y = ymin + j/rows*(ymax-ymin);
        for (let i=0;i<=cols;i++){
          const x = xmin + i/cols*(xmax-xmin);
          P[j*(cols+1)+i] = knnProbAt(x,y);
        }
      }
      const out = {cols, rows, xmin, xmax, ymin, ymax, P};
      state.gridCache = out;
      return out;
    }

    // resolución adaptativa según costo ~ N*K
    function gridColsAdaptive(){
      const load = state.n * state.k;
      if (load > 80000) return 60;
      if (load > 40000) return 80;
      if (load > 20000) return 100;
      return 130;
    }

    // ---------- Dibujo ----------
    function draw(){
      const [xmin,xmax]=state.xlim,[ymin,ymax]=state.ylim;
      const W=canvas.width,H=canvas.height;
      if (!W || !H) return;

      const m={l:48,r:16,t:18,b:44};
      const plotW=W-m.l-m.r, plotH=H-m.t-m.b;

      const x2px=(x)=> m.l + (x - xmin)/(xmax-xmin)*plotW;
      const y2px=(y)=> m.t + (1 - (y - ymin)/(ymax-ymin))*plotH;

      ctx.clearRect(0,0,W,H);
      // fondo
      ctx.fillStyle='#0c1226'; roundRect(ctx,m.l,m.t,plotW,plotH,10); ctx.fill();

      // grid de referencia
      ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
      drawGrid(ctx,x2px,y2px,xmin,xmax,ymin,ymax,m,W,H);

      // ejes 0
      ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=1.2;
      if (ymin<0 && ymax>0) line(ctx,m.l,y2px(0),m.l+plotW,y2px(0));
      if (xmin<0 && xmax>0) line(ctx,x2px(0),m.t,x2px(0),m.t+plotH);

      // fondo por probabilidad
      const cols = gridColsAdaptive();
      const grid = getGrid(cols);
      if (state.showProb){
        const {rows,P} = grid;
        for (let i=0;i<cols;i++){
          for (let j=0;j<rows;j++){
            // p en centro ~ promedio de esquinas
            const p00=P[j*(cols+1)+i], p10=P[j*(cols+1)+i+1], p01=P[(j+1)*(cols+1)+i], p11=P[(j+1)*(cols+1)+i+1];
            const p = (p00+p10+p01+p11)/4;
            const c0=[142,197,255], c1=[255,209,102];
            const r=Math.round(lerp(c0[0],c1[0],p));
            const g=Math.round(lerp(c0[1],c1[1],p));
            const b=Math.round(lerp(c0[2],c1[2],p));
            ctx.fillStyle=`rgba(${r},${g},${b},0.12)`;
            const X = m.l + i/cols*plotW, Y = m.t + j/rows*plotH;
            ctx.fillRect(X, Y, Math.ceil(plotW/cols), Math.ceil(plotH/rows));
          }
        }
      }

      // puntos (errores resaltados aprox usando grilla)
      for (let i=0;i<state.data.length;i++){
        const x1=state.xarr[i], x2=state.yarr[i], y=state.larr[i];
        const X=x2px(x1), Y=y2px(x2);
        ctx.fillStyle = (y===0)? getVar('--c0') : getVar('--c1');
        dot(ctx,X,Y,3.0);

        if (state.highlightErrors){
          const yhat = approxPredFromGrid(grid, x1, x2) >= 0.5 ? 1 : 0;
          if (yhat !== y){
            ctx.strokeStyle=getVar('--err'); ctx.lineWidth=1.4;
            ctx.beginPath(); ctx.arc(X,Y,5,0,Math.PI*2); ctx.stroke();
          }
        }
      }

      // frontera p=0.5 (marching squares sobre P-0.5)
      drawContour05(grid, x2px, y2px);

      // ticks
      drawTicks(ctx,x2px,y2px,xmin,xmax,ymin,ymax,m,W,H);
    }

    function approxPredFromGrid(grid, x, y){
      const {cols, rows, xmin, xmax, ymin, ymax, P} = grid;
      const fx = (x - xmin)/(xmax-xmin), fy = (y - ymin)/(ymax-ymin);
      const i = clamp(Math.floor(fx*cols), 0, cols-1);
      const j = clamp(Math.floor(fy*rows), 0, rows-1);
      const p00=P[j*(cols+1)+i], p10=P[j*(cols+1)+i+1], p01=P[(j+1)*(cols+1)+i], p11=P[(j+1)*(cols+1)+i+1];
      return (p00+p10+p01+p11)/4;
    }

    function drawContour05(grid, x2px, y2px){
      const {cols, rows, P} = grid;
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
      for (let j=0;j<rows;j++){
        for (let i=0;i<cols;i++){
          const a=P[j*(cols+1)+i]-0.5, b=P[j*(cols+1)+i+1]-0.5, c=P[(j+1)*(cols+1)+i+1]-0.5, d=P[(j+1)*(cols+1)+i]-0.5;
          const X0=i/cols, X1=(i+1)/cols, Y0=j/rows, Y1=(j+1)/rows;
          const idx=(a>0?8:0)|(b>0?4:0)|(c>0?2:0)|(d>0?1:0);
          const eps=1e-12;
          const eTop    = Math.abs(a-b)>eps ? {x: X0 + (a/(a-b))*(X1-X0), y:Y0} : null;
          const eRight  = Math.abs(b-c)>eps ? {x: X1, y: Y0 + (b/(b-c))*(Y1-Y0)} : null;
          const eBottom = Math.abs(d-c)>eps ? {x: X0 + (d/(d-c))*(X1-X0), y:Y1} : null;
          const eLeft   = Math.abs(a-d)>eps ? {x: X0, y: Y0 + (a/(a-d))*(Y1-Y0)} : null;
          const map = {
            1:[eLeft,eBottom], 2:[eBottom,eRight], 3:[eLeft,eRight], 4:[eTop,eRight],
            5:[eTop,eLeft, eBottom,eRight], 6:[eTop,eBottom], 7:[eTop,eLeft],
            8:[eTop,eLeft], 9:[eTop,eBottom], 10:[eTop,eRight, eLeft,eBottom], 11:[eTop,eRight],
            12:[eLeft,eRight], 13:[eBottom,eRight], 14:[eLeft,eBottom]
          }[idx];
          if (map){
            ctx.beginPath();
            for (let k=0;k<map.length;k+=2){
              const p1=map[k], p2=map[k+1];
              if (p1 && p2){
                ctx.moveTo( x2px(lerp(state.xlim[0], state.xlim[1], p1.x)),
                            y2px(lerp(state.ylim[0], state.ylim[1], p1.y)) );
                ctx.lineTo( x2px(lerp(state.xlim[0], state.xlim[1], p2.x)),
                            y2px(lerp(state.ylim[0], state.ylim[1], p2.y)) );
              }
            }
            ctx.stroke();
          }
        }
      }
    }

    // ---------- Helpers de dibujo ----------
    function roundRect(ctx, x,y,w,h,r){
      ctx.beginPath(); ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
    }
    function line(ctx,x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    function dot(ctx,x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
    function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    function niceTicks(min,max,count=6){
      const span=max-min; if (span<=0 || !isFinite(span)) return {start:min, step:1, count:1};
      const raw=span/count; const mag=10**Math.floor(Math.log10(Math.abs(raw))); const norm=raw/mag;
      const nice = norm<1.5?1: norm<3?2: norm<7?5:10;
      const step=nice*mag; const start=Math.ceil(min/step)*step; const end=Math.floor(max/step)*step;
      const n=Math.max(1, Math.round((end-start)/step)+1); return {start, step, count:n};
    }
    function drawGrid(ctx,x2px,y2px,xmin,xmax,ymin,ymax,m,W,H){
      const xt=niceTicks(xmin,xmax,6);
      for(let i=0;i<xt.count;i++){ const x=xt.start+i*xt.step; line(ctx, x2px(x), m.t, x2px(x), H-m.b); }
      const yt=niceTicks(ymin,ymax,6);
      for(let i=0;i<yt.count;i++){ const y=yt.start+i*yt.step; line(ctx, m.l, y2px(y), W-m.r, y2px(y)); }
    }
    function drawTicks(ctx,x2px,y2px,xmin,xmax,ymin,ymax,m,W,H){
      ctx.fillStyle='rgba(231,236,243,0.9)'; ctx.font='12px system-ui, sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='top';
      const xt=niceTicks(xmin,xmax,6);
      for(let i=0;i<xt.count;i++){ const x=xt.start+i*xt.step; ctx.fillText(fmt(x), x2px(x), H-m.b+6); }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      const yt=niceTicks(ymin,ymax,6);
      for(let i=0;i<yt.count;i++){ const y=yt.start+i*yt.step; ctx.fillText(fmt(y), m.l-6, y2px(y)); }
    }
    const fmt=(v)=> !isFinite(v)?'–': (Math.abs(v)>=10? v.toFixed(2): v.toFixed(3));

    // ---------- UI & Resize ----------
    function refresh(resize=true){
      kVal.textContent = state.k;
      pVal.textContent = (+state.p).toFixed(2);
      // métricas
      const {acc, ll, tn, fp, fn, tp} = evaluate();
      accEl.textContent = isFinite(acc)? (acc*100).toFixed(1)+'%':'–';
      accEl.className = (acc>=0.9)?'ok' : (acc>=0.7)?'warn':'err';
      llEl.textContent = isFinite(ll)? ll.toFixed(4): '–';
      tnEl.textContent = tn; fpEl.textContent = fp; fnEl.textContent = fn; tpEl.textContent = tp;

      if (resize) resizeCanvasToDisplaySize();
      draw();
    }

    kInp.addEventListener('input', ()=>{ state.k=+kInp.value|0; state.gridCache=null; refresh(false); });
    metricSel.addEventListener('change', ()=>{
      state.metric=metricSel.value; pRow.style.display = (state.metric==='mink')?'grid':'none';
      state.gridCache=null; refresh(false);
    });
    pInp.addEventListener('input', ()=>{ state.p=+pInp.value; state.gridCache=null; refresh(false); });

    shapeSel.addEventListener('change', ()=>{ state.shape=shapeSel.value; });
    sigmaInp.addEventListener('change', ()=>{ state.sigma=Math.max(0,+sigmaInp.value); });
    nInp.addEventListener('change', ()=>{ state.n=Math.max(60,+nInp.value|0); });
    seedInp.addEventListener('change', ()=>{ state.seed=+seedInp.value|0; });

    regenBtn.addEventListener('click', ()=>{ genData(); refresh(); });
    toggleProb.addEventListener('change', ()=>{ state.showProb=toggleProb.checked; draw(); });
    toggleErr .addEventListener('change', ()=>{ state.highlightErrors=toggleErr.checked; draw(); });

    resetGoodBtn.addEventListener('click', ()=>{
      state.k=15; kInp.value=15; kVal.textContent='15';
      state.metric='l2'; metricSel.value='l2'; pRow.style.display='none'; state.p=2.0; pInp.value=2.0; pVal.textContent='2.0';
      state.gridCache=null; refresh(false);
    });

    function resizeCanvasToDisplaySize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const cssW = Math.max(1, Math.round(rect.width));
      const cssH = Math.max(1, Math.round(rect.height));
      const wantW = Math.round(cssW * dpr);
      const wantH = Math.round(cssH * dpr);
      if (canvas.width!==wantW || canvas.height!==wantH){
        canvas.width = wantW; canvas.height = wantH;
      }
      ctx.setTransform(1,0,0,1,0,0);
    }
    const ro = new ResizeObserver(()=>{ resizeCanvasToDisplaySize(); draw(); });

    // ---------- Init ----------
    function init(){
      // estado inicial desde inputs
      kInp.value=state.k; kVal.textContent=state.k;
      metricSel.value=state.metric; pInp.value=state.p; pVal.textContent=state.p.toFixed(2);
      pRow.style.display = (state.metric==='mink')?'grid':'none';
      shapeSel.value=state.shape; sigmaInp.value=state.sigma; nInp.value=state.n; seedInp.value=state.seed;

      genData();
      requestAnimationFrame(()=>{
        ro.observe(canvas);
        refresh();
      });
      matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`).addEventListener?.('change', ()=>{
        resizeCanvasToDisplaySize(); draw();
      });
    }
    init();
  </script>
</body>
</html>

