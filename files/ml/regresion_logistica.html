<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clasificación binaria — Regresión logística 2D</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1428; --ink:#e7ecf3; --muted:#9aa4b2; --accent:#78a6ff; --border:#1e2646;
      --ok:#21c07a; --warn:#ffb454; --err:#ef476f;
      --c0:#8ec5ff; --c1:#ffd166;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--ink);
      background:radial-gradient(1200px 700px at 20% -10%, #162045 0%, var(--bg) 50%);
      font:15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif;
    }
    .container{max-width:1100px; margin:0 auto; padding:28px 16px 60px;}
    header{display:grid; gap:8px; margin-bottom:18px}
    h1{margin:0; font-size:clamp(22px, 2vw + 16px, 34px)}
    .muted{color:var(--muted)}
    .grid{display:grid; gap:16px; grid-template-columns:repeat(12,1fr)}
    .card{
      grid-column:span 8; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
      border:1px solid var(--border); border-radius:18px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.2)
    }
    .side{grid-column:span 4; display:flex; flex-direction:column; gap:16px}
    @media (max-width: 980px){ .card,.side{grid-column:1 / -1} }
    canvas{width:100%; height:480px; display:block; background:#0c1226; border:1px solid var(--border); border-radius:14px}
    .controls{display:grid; gap:12px}
    .row{display:grid; grid-template-columns: 140px 1fr auto; gap:10px; align-items:center}
    .row input[type="range"]{width:100%}
    .pill{display:inline-block; background:#0e1a3c; border:1px solid var(--border); border-radius:999px; padding:2px 8px; font-size:12px; color:var(--muted)}
    .legend{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .dot{width:10px; height:10px; border-radius:50%}
    .c0{background:var(--c0)} .c1{background:var(--c1)}
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:8px 12px; border-radius:12px; border:1px solid var(--border);
      background:#0f1734; color:var(--ink); cursor:pointer; user-select:none
    }
    .btn:active{transform:translateY(1px)}
    .panel{background:#0f1428; border:1px solid var(--border); border-radius:14px; padding:12px}
    .mono{font:13px/1.6 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    details{border:1px solid var(--border); border-radius:12px; background:#0d1328; padding:10px}
    summary{cursor:pointer}
    table{width:100%; border-collapse:collapse; font-size:13px}
    th,td{padding:6px 8px; border-bottom:1px solid #141a33; text-align:right}
    th:first-child, td:first-child{text-align:left}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    input[type="number"]{
      background:#0d1631; color:var(--ink); border:1px solid var(--border); border-radius:10px; padding:6px 8px; width:100%;
    }
    .cols{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    @media (max-width:560px){ .row{grid-template-columns: 110px 1fr auto} .cols{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Regresión logística 2D (clasificación)</h1>
      <div class="muted">Mové los sliders de <strong>w1</strong>, <strong>w2</strong> y <strong>b</strong> para ver cómo cambia la <em>frontera de decisión</em> y las métricas.</div>
      <div class="legend">
        <span class="pill"><span class="dot c0"></span> clase 0</span>
        <span class="pill"><span class="dot c1"></span> clase 1</span>
        <span class="pill">línea: <em>w1·x1 + w2·x2 + b = 0</em></span>
      </div>
    </header>

    <section class="grid">
      <div class="card">
        <canvas id="plot" width="900" height="480" aria-label="Plano X1–X2 con puntos y frontera de decisión"></canvas>
      </div>

      <aside class="side">
        <div class="panel controls">
          <div class="row">
            <label for="w1">Coeficiente w1 (x1)</label>
            <input id="w1" type="range" min="-6" max="6" step="0.1" value="1.0" />
            <output id="w1Val">1.0</output>
          </div>
          <div class="row">
            <label for="w2">Coeficiente w2 (x2)</label>
            <input id="w2" type="range" min="-6" max="6" step="0.1" value="1.0" />
            <output id="w2Val">1.0</output>
          </div>
          <div class="row">
            <label for="b">Término independiente b</label>
            <input id="b" type="range" min="-10" max="10" step="0.1" value="0.0" />
            <output id="bVal">0.0</output>
          </div>

          <div class="cols">
            <div>
              <label class="muted" for="sigma">Disp. (σ)</label>
              <input id="sigma" type="number" step="0.1" value="1.2" />
            </div>
            <div>
              <label class="muted" for="n">Muestras N</label>
              <input id="n" type="number" min="20" max="2000" step="10" value="300" />
            </div>
          </div>
          <div class="cols">
            <div>
              <label class="muted" for="seed">Semilla</label>
              <input id="seed" type="number" step="1" value="1234" />
            </div>
            <div style="display:flex; align-items:flex-end;">
              <button id="regen" class="btn" type="button" title="Regenerar puntos">Regenerar datos</button>
            </div>
          </div>

          <details>
            <summary class="muted">Ajustar por LogLoss (GD) — opcional</summary>
            <div class="cols" style="margin-top:8px;">
              <div>
                <label class="muted" for="lr">LR</label>
                <input id="lr" type="number" step="0.01" value="0.1" />
              </div>
              <div>
                <label class="muted" for="epochs">Épocas</label>
                <input id="epochs" type="number" step="10" value="300" />
              </div>
            </div>
            <div style="margin-top:8px;">
              <button id="train" class="btn" type="button">Ajustar (descenso por gradiente)</button>
            </div>
          </details>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:4px;">
            <label class="muted" style="display:flex; align-items:center; gap:6px;">
              <input id="toggleErr" type="checkbox" checked/> Resaltar mal clasificados
            </label>
            <label class="muted" style="display:flex; align-items:center; gap:6px;">
              <input id="toggleProb" type="checkbox"/> Fondo según probabilidad
            </label>
          </div>
        </div>

        <div class="panel mono" id="metrics">
          <div><strong>Accuracy:</strong> <span id="acc" class="ok">–</span></div>
          <div><strong>LogLoss:</strong> <span id="ll">–</span></div>
        </div>

        <details>
          <summary class="muted">Matriz de confusión</summary>
          <div style="margin-top:8px;">
            <table id="cm">
              <thead>
                <tr><th></th><th>Pred 0</th><th>Pred 1</th></tr>
              </thead>
              <tbody>
                <tr><td>True 0</td><td id="tn">–</td><td id="fp">–</td></tr>
                <tr><td>True 1</td><td id="fn">–</td><td id="tp">–</td></tr>
              </tbody>
            </table>
          </div>
        </details>
      </aside>
    </section>
  </div>

  <script>
    // ---------- Utils ----------
    function mulberry32(seed){ let t = seed>>>0; return function(){
      t += 0x6D2B79F5; let r = Math.imul(t ^ (t>>>15), 1|t); r ^= r + Math.imul(r ^ (r>>>7), 61|r);
      return ((r ^ (r>>>14))>>>0) / 4294967296;
    }}
    function randn(rng){ let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
    const sigmoid = (z)=> 1/(1+Math.exp(-z));
    const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

    // ---------- Estado ----------
    const state = {
      data: [],       // {x1, x2, y}
      xlim: [-6, 6],
      ylim: [-6, 6],
      w1: 1.0, w2: 1.0, b: 0.0,
      sigma: 1.2,
      n: 300,
      seed: 1234,
      highlightErrors: true,
      showProb: false,
    };

    // ---------- DOM ----------
    const $ = (sel)=>document.querySelector(sel);
    const canvas = $('#plot'); const ctx = canvas.getContext('2d');

    const w1Inp=$('#w1'), w2Inp=$('#w2'), bInp=$('#b');
    const w1Val=$('#w1Val'), w2Val=$('#w2Val'), bVal=$('#bVal');

    const sigmaInp=$('#sigma'), nInp=$('#n'), seedInp=$('#seed');
    const regenBtn=$('#regen'), trainBtn=$('#train');
    const lrInp=$('#lr'), epochsInp=$('#epochs');
    const toggleErr=$('#toggleErr'), toggleProb=$('#toggleProb');

    const accEl=$('#acc'), llEl=$('#ll');
    const tnEl=$('#tn'), fpEl=$('#fp'), fnEl=$('#fn'), tpEl=$('#tp');

    // ---------- Datos: dos nubes gaussianas (linealmente separables con ruido) ----------
    function genData(){
      const rng = mulberry32(+state.seed || 0);
      const N = Math.max(20, +state.n|0);
      const s = Math.max(0, +state.sigma);

      const c0 = {x1:-2.2, x2:-1.5};
      const c1 = {x1: 2.2, x2:  1.5};

      const arr=[];
      for (let i=0;i<N;i++){
        const y = (i%2); // mitad y mitad
        const c = y ? c1 : c0;
        const x1 = c.x1 + randn(rng)*s;
        const x2 = c.x2 + randn(rng)*s;
        arr.push({x1,x2,y});
      }
      state.data = arr;
      // Ajustar límites si hace falta
      const xs = arr.map(d=>d.x1), ys = arr.map(d=>d.x2);
      const xMin = Math.min(...xs), xMax = Math.max(...xs);
      const yMin = Math.min(...ys), yMax = Math.max(...ys);
      const padX = 0.15*(xMax-xMin||1), padY = 0.15*(yMax-yMin||1);
      state.xlim = [xMin-padX, xMax+padX];
      state.ylim = [yMin-padY, yMax+padY];
    }

    // ---------- Métricas ----------
    function evaluate(w1, w2, b){
      const eps = 1e-9;
      let correct=0, ll=0, tn=0, tp=0, fn=0, fp=0;
      for (const {x1,x2,y} of state.data){
        const p = sigmoid(w1*x1 + w2*x2 + b);
        const yhat = (p>=0.5)?1:0;
        if (yhat===y) correct++;
        ll += -(y*Math.log(clamp(p,eps,1-eps)) + (1-y)*Math.log(clamp(1-p,eps,1-eps)));
        if (y===1 && yhat===1) tp++;
        else if (y===1 && yhat===0) fn++;
        else if (y===0 && yhat===1) fp++;
        else tn++;
      }
      const acc = correct/state.data.length;
      return {acc, ll: ll/state.data.length, tn, fp, fn, tp};
    }

    // ---------- Descenso por gradiente sobre LogLoss ----------
    async function trainGD(){
      let w1 = state.w1, w2 = state.w2, b = state.b;
      const lr = +lrInp.value || 0.1;
      const epochs = Math.max(1, +epochsInp.value|0);
      const n = state.data.length;

      for (let e=0; e<epochs; e++){
        let gw1=0, gw2=0, gb=0;
        for (const {x1,x2,y} of state.data){
          const p = sigmoid(w1*x1 + w2*x2 + b);
          const diff = (p - y);
          gw1 += diff * x1;
          gw2 += diff * x2;
          gb  += diff;
        }
        gw1/=n; gw2/=n; gb/=n;
        w1 -= lr*gw1; w2 -= lr*gw2; b -= lr*gb;

        // cada 50 épocas, refrescamos UI para feedback
        if ((e+1)%50===0) {
          state.w1=w1; state.w2=w2; state.b=b;
          w1Inp.value=w1.toFixed(2); w2Inp.value=w2.toFixed(2); bInp.value=b.toFixed(2);
          refresh(false); // sin recálculo de canvas size
          await new Promise(r=>requestAnimationFrame(r));
        }
      }
      state.w1=w1; state.w2=w2; state.b=b;
      w1Inp.value=w1.toFixed(2); w2Inp.value=w2.toFixed(2); bInp.value=b.toFixed(2);
      refresh(false);
    }

    // ---------- Dibujo ----------
    function draw(){
      const [xmin,xmax]=state.xlim, [ymin,ymax]=state.ylim;

      // proyecciones a pixeles (usamos tamaño real del canvas, no CSS)
      const W=canvas.width, H=canvas.height;
      const m={l:48, r:16, t:18, b:44};
      const plotW=W-m.l-m.r, plotH=H-m.t-m.b;

      const x2px=(x)=> m.l + (x - xmin)/(xmax-xmin)*plotW;
      const y2px=(y)=> m.t + (1 - (y - ymin)/(ymax-ymin))*plotH;

      ctx.clearRect(0,0,W,H);

      // fondo
      ctx.fillStyle='#0c1226';
      roundRect(ctx, m.l, m.t, plotW, plotH, 10); ctx.fill();

      // grid
      ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
      drawGrid(ctx, x2px, y2px, xmin, xmax, ymin, ymax, m, W, H);

      // eje 0 si entra
      ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=1.2;
      if (ymin<0 && ymax>0){ line(ctx, m.l, y2px(0), m.l+plotW, y2px(0)); }
      if (xmin<0 && xmax>0){ line(ctx, x2px(0), m.t, x2px(0), m.t+plotH); }

      // fondo de probabilidad (opcional, sampling rápido)
      if (state.showProb){
        const cols = 140, rows = Math.round(cols * plotH/plotW);
        const dx = (xmax - xmin)/cols, dy=(ymax - ymin)/rows;
        for (let i=0;i<cols;i++){
          for (let j=0;j<rows;j++){
            const x = xmin + (i+0.5)*dx;
            const y = ymin + (j+0.5)*dy;
            const p = sigmoid(state.w1*x + state.w2*y + state.b); // prob de clase 1
            // mezclar colores base (c0 y c1) según p
            const c0=[142,197,255], c1=[255,209,102];
            const r=Math.round(c0[0]*(1-p)+c1[0]*p);
            const g=Math.round(c0[1]*(1-p)+c1[1]*p);
            const b=Math.round(c0[2]*(1-p)+c1[2]*p);
            ctx.fillStyle = `rgba(${r},${g},${b},0.10)`;
            const X = m.l + i/cols*plotW, Y = m.t + j/rows*plotH;
            ctx.fillRect(X, Y, plotW/cols+1, plotH/rows+1);
          }
        }
      }

      // puntos
      for (const {x1,x2,y} of state.data){
        const p = sigmoid(state.w1*x1 + state.w2*x2 + state.b);
        const yhat = (p>=0.5)?1:0;
        const X=x2px(x1), Y=y2px(x2);
        ctx.fillStyle = (y===0)? getVar('--c0') : getVar('--c1');
        dot(ctx, X, Y, 3.2);
        // remarcar errores si está activo
        if (state.highlightErrors && y!==yhat){
          ctx.strokeStyle = getVar('--err'); ctx.lineWidth=1.5;
          ctx.beginPath(); ctx.arc(X,Y,5,0,Math.PI*2); ctx.stroke();
        }
      }

      // frontera de decisión: w1*x + w2*y + b = 0 => y = -(w1/w2)x - b/w2 (si w2 != 0)
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
      const eps=1e-9;
      if (Math.abs(state.w2) > eps){
        const y_at_xmin = -(state.w1/xmin === Infinity ? 0 : (state.w1/ state.w2))*xmin - state.b/state.w2;
        const y_at_xmax = -(state.w1/xmax === Infinity ? 0 : (state.w1/ state.w2))*xmax - state.b/state.w2;

        // recortar a caja
        const A = clipToBox(xmin, xmax, ymin, ymax, xmin, y_at_xmin, xmax, y_at_xmax);
        if (A){
          line(ctx, x2px(A.x1), y2px(A.y1), x2px(A.x2), y2px(A.y2));
        }
      } else if (Math.abs(state.w1) > eps){
        // línea vertical: x = -b/w1
        const x = -state.b / state.w1;
        if (x>xmin && x<xmax){
          line(ctx, x2px(x), y2px(ymin), x2px(x), y2px(ymax));
        }
      }

      // ticks y labels
      drawTicks(ctx, x2px, y2px, xmin, xmax, ymin, ymax, m, W, H);
    }

    function roundRect(ctx, x,y,w,h,r){
      ctx.beginPath(); ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function line(ctx,x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    function dot(ctx,x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
    function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    function niceTicks(min,max,count=6){
      const span=max-min; if (span<=0 || !isFinite(span)) return {start:min, step:1, count:1};
      const raw=span/count; const mag=10**Math.floor(Math.log10(Math.abs(raw))); const norm=raw/mag;
      const nice = norm<1.5?1: norm<3?2: norm<7?5:10;
      const step=nice*mag; const start=Math.ceil(min/step)*step; const end=Math.floor(max/step)*step;
      const n=Math.max(1, Math.round((end-start)/step)+1); return {start, step, count:n};
    }
    function drawGrid(ctx,x2px,y2px,xmin,xmax,ymin,ymax,m,W,H){
      const xt=niceTicks(xmin,xmax,6);
      ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
      for(let i=0;i<xt.count;i++){ const x=xt.start+i*xt.step; line(ctx, x2px(x), m.t, x2px(x), H-m.b); }
      const yt=niceTicks(ymin,ymax,6);
      for(let i=0;i<yt.count;i++){ const y=yt.start+i*yt.step; line(ctx, m.l, y2px(y), W-m.r, y2px(y)); }
    }
    function drawTicks(ctx,x2px,y2px,xmin,xmax,ymin,ymax,m,W,H){
      ctx.fillStyle='rgba(231,236,243,0.9)'; ctx.font='12px system-ui, sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='top';
      const xt=niceTicks(xmin,xmax,6);
      for(let i=0;i<xt.count;i++){ const x=xt.start+i*xt.step; ctx.fillText(fmt(x), x2px(x), H-m.b+6); }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      const yt=niceTicks(ymin,ymax,6);
      for(let i=0;i<yt.count;i++){ const y=yt.start+i*yt.step; ctx.fillText(fmt(y), m.l-6, y2px(y)); }
    }
    const fmt=(v)=> !isFinite(v)?'–': (Math.abs(v)>=10? v.toFixed(2): v.toFixed(3));

    // Recorte de segmento a caja (Cohen–Sutherland simple)
    function clipToBox(xmin,xmax,ymin,ymax,x1,y1,x2,y2){
      let code = (x,y)=> (y>ymax?8: y<ymin?4:0) | (x>xmax?2: x<xmin?1:0);
      let c1=code(x1,y1), c2=code(x2,y2);
      while(true){
        if (!(c1|c2)) return {x1,y1,x2,y2};
        if (c1&c2) return null;
        let c = c1?c1:c2, x,y;
        if (c&8){ x=x1+(x2-x1)*(ymax-y1)/(y2-y1); y=ymax; }
        else if (c&4){ x=x1+(x2-x1)*(ymin-y1)/(y2-y1); y=ymin; }
        else if (c&2){ y=y1+(y2-y1)*(xmax-x1)/(x2-x1); x=xmax; }
        else { y=y1+(y2-y1)*(xmin-x1)/(x2-x1); x=xmin; }
        if (c===c1){ x1=x; y1=y; c1=code(x1,y1); } else { x2=x; y2=y; c2=code(x2,y2); }
      }
    }

    // ---------- UI + métricas ----------
    function refresh(resize=true){
      w1Val.textContent = (+state.w1).toFixed(2);
      w2Val.textContent = (+state.w2).toFixed(2);
      bVal.textContent  = (+state.b ).toFixed(2);

      const {acc, ll, tn, fp, fn, tp} = evaluate(state.w1, state.w2, state.b);
      accEl.textContent = isFinite(acc)? (acc*100).toFixed(1)+'%':'–';
      accEl.className = (acc>=0.85)?'ok': (acc>=0.6)?'warn':'err';
      llEl.textContent = isFinite(ll)? ll.toFixed(4): '–';
      tnEl.textContent = tn; fpEl.textContent = fp; fnEl.textContent = fn; tpEl.textContent = tp;

      if (resize) resizeCanvasToDisplaySize();
      draw();
    }

    // ---------- Binding de inputs ----------
    w1Inp.addEventListener('input', ()=>{ state.w1=+w1Inp.value; refresh(false); });
    w2Inp.addEventListener('input', ()=>{ state.w2=+w2Inp.value; refresh(false); });
    bInp .addEventListener('input', ()=>{ state.b =+bInp.value ; refresh(false); });

    toggleErr.addEventListener('change', ()=>{ state.highlightErrors = toggleErr.checked; draw(); });
    toggleProb.addEventListener('change', ()=>{ state.showProb = toggleProb.checked; draw(); });

    sigmaInp.addEventListener('change', ()=>{ state.sigma = Math.max(0,+sigmaInp.value); });
    nInp.addEventListener('change', ()=>{ state.n = Math.max(20, +nInp.value|0); });
    seedInp.addEventListener('change', ()=>{ state.seed = +seedInp.value|0; });

    regenBtn.addEventListener('click', ()=>{ genData(); refresh(); });
    trainBtn?.addEventListener('click', ()=>{ trainGD(); });

    // ---------- Resize (HiDPI, sin doble escala) ----------
    function resizeCanvasToDisplaySize(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = Math.max(1, canvas.clientWidth);
      const cssH = Math.max(1, canvas.clientHeight);
      const wantW = Math.round(cssW * dpr);
      const wantH = Math.round(cssH * dpr);
      if (canvas.width!==wantW || canvas.height!==wantH){
        canvas.width = wantW; canvas.height = wantH;
      }
      ctx.setTransform(1,0,0,1,0,0);
    }

    // ---------- Init ----------
    function init(){
      state.sigma=+sigmaInp.value; state.n=+nInp.value; state.seed=+seedInp.value;
      genData();
      // valores iniciales razonables para la frontera
      state.w1=1; state.w2=1; state.b=0;
      w1Inp.value=state.w1.toFixed(2); w2Inp.value=state.w2.toFixed(2); bInp.value=state.b.toFixed(2);
      refresh();
      window.addEventListener('resize', ()=>{ resizeCanvasToDisplaySize(); draw(); });
    }
    init();
  </script>
</body>
</html>

